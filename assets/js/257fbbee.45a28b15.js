"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[121],{2322:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"scenarios/S08_Concurrency_conflicts","title":"Optimistic Concurrency","description":"This scenario demonstrates how to handle optimistic concurrency conflicts in Streamstone.","source":"@site/docs/scenarios/S08_Concurrency_conflicts.md","sourceDirName":"scenarios","slug":"/scenarios/S08_Concurrency_conflicts","permalink":"/Streamstone/docs/scenarios/S08_Concurrency_conflicts","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Virtual Partitions","permalink":"/Streamstone/docs/scenarios/Virtual_partitions"},"next":{"title":"Handling Duplicate Events","permalink":"/Streamstone/docs/scenarios/S09_Handling_duplicates"}}');var a=t(4848),i=t(8453);const o={},s="Optimistic Concurrency",c={},l=[];function u(n){const e={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,i.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"optimistic-concurrency",children:"Optimistic Concurrency"})}),"\n",(0,a.jsx)(e.p,{children:"This scenario demonstrates how to handle optimistic concurrency conflicts in Streamstone."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-csharp",metastring:'title="S08_Concurrency_conflicts.cs"',children:'using System;\nusing System.Threading.Tasks;\n\nusing Streamstone;\n\nnamespace Example.Scenarios\n{\n    public class S08_Concurrency_conflicts : Scenario\n    {\n        public override async Task RunAsync()\n        {\n            await SimultaneousProvisioning();\n            await SimultaneousWriting();\n            await SimultaneousSettingOfStreamMetadata();\n            await SequentiallyWritingToStreamIgnoringReturnedStreamHeader();\n        }\n\n        async Task SimultaneousProvisioning()\n        {\n            await Stream.ProvisionAsync(Partition);\n\n            try\n            {\n                await Stream.ProvisionAsync(Partition);\n            }\n            catch (ConcurrencyConflictException)\n            {\n                Console.WriteLine("Simultaneously provisioning stream in a same partition will lead to ConcurrencyConflictException");\n            }\n        }\n\n        async Task SimultaneousWriting()\n        {\n            var a = await Stream.OpenAsync(Partition);\n            var b = await Stream.OpenAsync(Partition);\n\n            await Stream.WriteAsync(a, new EventData(EventId.From("123")));\n            \n            try\n            {\n                await Stream.WriteAsync(b, new EventData(EventId.From("456")));\n            }\n            catch (ConcurrencyConflictException)\n            {\n                Console.WriteLine("Simultaneously writing to the same version of stream will lead to ConcurrencyConflictException");\n            }\n        }\n\n        async Task SimultaneousSettingOfStreamMetadata()\n        {\n            var a = await Stream.OpenAsync(Partition);\n            var b = await Stream.OpenAsync(Partition);\n\n            await Stream.SetPropertiesAsync(a, StreamProperties.From(new {A = 42}));\n\n            try\n            {\n                await Stream.SetPropertiesAsync(b, StreamProperties.From(new {A = 56}));\n            }\n            catch (ConcurrencyConflictException)\n            {\n                Console.WriteLine("Simultaneously setting metadata using the same version of stream will lead to ConcurrencyConflictException");\n            }\n        }\n\n        async Task SequentiallyWritingToStreamIgnoringReturnedStreamHeader()\n        {\n            var stream = await Stream.OpenAsync(Partition);\n\n            var result = await Stream.WriteAsync(stream, new EventData(EventId.From("AAA")));\n            \n            // a new stream header is returned after each write, it contains new Etag\n            // and it should be used for subsequent operations\n            // stream = result.Stream; \n            \n            try\n            {\n                await Stream.WriteAsync(stream, new EventData(EventId.From("BBB")));\n            }\n            catch (ConcurrencyConflictException)\n            {\n                Console.WriteLine("Ignoring new stream (header) returned after each Write() operation will lead to ConcurrencyConflictException on subsequent write operation");\n            }\n        }\n    }\n}\n'})})]})}function m(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(u,{...n})}):u(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>s});var r=t(6540);const a={},i=r.createContext(a);function o(n){const e=r.useContext(i);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:o(n.components),r.createElement(i.Provider,{value:e},n.children)}}}]);