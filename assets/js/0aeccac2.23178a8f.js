"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[965],{7113:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/Schema_VP-c15800adfda65048022d363a27d10578.png"},8118:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/Schema-7ec124683f4b34697d0fe40a7103cf42.png"},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var i=n(6540);const s={},a=i.createContext(s);function o(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:t},e.children)}},9104:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"design","title":"Design","description":"Streamstone is a thin library layer on top of Windows Azure Table Storage. It implements the low-level mechanics for dealing with event streams, while all heavy lifting is done by the underlying provider.","source":"@site/docs/design.md","sourceDirName":".","slug":"/design","permalink":"/Streamstone/docs/design","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"design","title":"Design"},"sidebar":"tutorialSidebar","previous":{"title":"Sharding Streams","permalink":"/Streamstone/docs/scenarios/S11_Sharding_streams"},"next":{"title":"Limitations","permalink":"/Streamstone/docs/limitations"}}');var s=n(4848),a=n(8453);const o={id:"design",title:"Design"},r=void 0,l={},c=[{value:"Schema",id:"schema",level:2}];function d(e){const t={h2:"h2",hr:"hr",img:"img",li:"li",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"Streamstone is a thin library layer on top of Windows Azure Table Storage. It implements the low-level mechanics for dealing with event streams, while all heavy lifting is done by the underlying provider."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The API is stateless and all exposed objects are immutable once constructed."}),"\n",(0,s.jsx)(t.li,{children:"Streamstone does not dictate the payload serialization protocol, so you are free to choose any protocol you want."}),"\n",(0,s.jsx)(t.li,{children:"Optimistic concurrency is implemented by always including a stream header entity with every write, making it impossible to append to a stream without first having the latest Etag."}),"\n",(0,s.jsx)(t.li,{children:"Duplicate event detection is done by automatically creating an additional entity for every event, with RowKey set to a unique identifier of the source event (consistent secondary index)."}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"schema",children:"Schema"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Schema",src:n(8118).A+"",width:"1061",height:"597"})}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Schema for virtual partitions",src:n(7113).A+"",width:"1061",height:"597"})})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);